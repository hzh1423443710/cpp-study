# STL标准模板库

## 一:容器

### 1. priority_queue优先级队列

```c++
#include<iostream>
#include<string>
#include<vector>
#include<queue>
using namespace std;

class mm
{
	friend ostream& operator<<(ostream& output, const mm& s)
	{
		output << s.name << " " << s.age << endl;
		return output;
	}
public:
	mm():age(0),name("") {}
	mm(int age,string name):age(age),name(name) {}
	int getAge()const 
	{
		return age;
	}
public:
	/*方法一*/
	friend bool operator<(const mm& e1, const mm& e2)
	{
		return e1.age > e2.age;
	}
	friend bool operator>(const mm& e1, const mm& e2)
	{
		return e1.age < e2.age;
	}
	/*方法二*/
	//bool operator<(const mm& e)const  //必须为const 常对象只能调用常成员函数
	//{
	//	return this->age > e.age;
	//}
	//bool operator>(const mm& e)const  //必须为const 常对象只能调用常成员函数
	//{
	//	return this->age < e.age;
	//}
private:
	int age;
	string name;
};
/*方法三:重载()*/
class CompareAge
{
public:
	bool operator()(const mm& e1, const mm& e2)
	{
		return e1.getAge() > e2.getAge();
	}
};

int main()
{
	//priority_queue<mm, vector<mm>, CompareAge> q;
	priority_queue<mm, vector<mm>, less<mm>> q;
	q.push(mm(20, "hzh4"));
	q.push(mm(21, "hzh1"));
	q.push(mm(23, "hzh3"));
	q.push(mm(22, "hzh2"));
	while (!q.empty())
	{
		cout << q.top();
		q.pop();
	}
	return 0;
}
```

### 2. initializer_list初始化列表

```c++
#include<iostream>
#include<string>
#include<vector>
#include<initializer_list>
using namespace std;

class my_vector
{
public:
	my_vector():arr(nullptr),size(0){}
	my_vector(int size)
	{
		this->size = size;
		arr = new int[size];
	}
	my_vector(const initializer_list<int>& l)
	{
		size = l.size();
		arr = new int[size];
		int i = 0;
		for (initializer_list<int>::iterator it = l.begin(); it != l.end(); it++,i++)
		{
			*(arr+i) = *it;
		}
	}
	int Size()
	{
		return size;
	}
public:
	int& operator[](int i)
	{
		return arr[i];
	}
private:
	int* arr;
	int size;
};

int main()
{
	my_vector s = { 1,2,3,4,5,6,7,8,9 };

	for (int i = 0; i < s.Size(); i++)
		cout << s[i] << " ";
	cout << endl;
	return 0;
}
```

### 3.集合set

#### 	自带排序,去重

```c++
#include<iostream>
#include<string>
#include<set>
#include<bitset>
using namespace std;

class aa
{
#if 0
	friend bool operator<(const aa& s1, const aa& s2)
	{
		return s1.age < s2.age;
	}
	friend bool operator>(const aa& s1, const aa& s2)
	{
		return s1.age > s2.age;
	}
#endif
	friend ostream& operator<<(ostream& output, const aa& s) 
	{
		output << s.age << "\t" << s.name;
		return output;
	}
public:
	aa() = default;
	aa(int age, string name) :age(age), name(name){}
	bool operator<(const aa& s) const 
	{
		return this->age < s.age;
	}
	int getAge() const 
	{
		return age;
	}
	string getName()const
	{
		return name;
	}
private:
	int age;
	string name;
};

class compare_Name
{
public:
	bool operator()(const aa& s1, const aa& s2)const//const不能丢
	{
		return s1.getName() < s2.getName();
	}
};

int main()
{
	cout << "------------------集合set---------------" << endl;
	set<aa, compare_Name> s;
	s.insert(aa(20, "def"));
	s.insert(aa(8, "abc"));
	s.insert(aa(14, "bfg"));
	s.insert(aa(10, "cjk"));
	for (auto v : s)
	{
		cout << v << endl;
	}
	cout << endl;
	cout << "------------------多重集合multiset不去重---------------" << endl;
	multiset<int> f;
	for (int i = 0; i < 10; i++)
	{
		f.insert(i);
	}
	cout << "f.size()= " << f.size() << endl;
	for (int i = 0; i < 10; i++)
	{
		f.insert(i);
	}
	cout << "f.size()= " << f.size() << endl;
	for (auto v : f)
	{
		cout << v<<" ";
	}
	cout << endl;
	cout << "------------------操作二进制---------------" << endl;
	bitset<8> b(255);
	cout << b << endl;
	cout << "bitset位数:" << b.count() << endl;
	cout << "是否有1	    :" << b.any() << endl;
	cout << "是否不存在1 :" << b.none() << endl;
	cout <<"取反:"<< b.flip() << endl;
	bitset<8>  ss("1111");
	cout << ss << endl;
	cout << "to_string:" << ss.to_string();
	return 0;
}
```

### 4. 映射map

* **pair map multimap**

#### 	自带排序去重

```c++
#include<iostream>
#include<string>
#include<vector>
#include<map>
using namespace std;

class aa
{
#if 1
	friend bool operator<(const aa& s1, const aa& s2)
	{
		return s1.age < s2.age;
	}
	friend bool operator>(const aa& s1, const aa& s2)
	{
		return s1.age > s2.age;
	}
#endif
	friend ostream& operator<<(ostream& output, const aa& s)
	{
		output << "[" << s.age << "," << s.name <<"]";
		return output;
	}
public:
	aa() = default;
	aa(int age, string name) :age(age), name(name){}
	//bool operator<(const aa& s) const 
	//{
	//	return this->age < s.age;
	//}
	int getAge() const 
	{
		return age;
	}
	string getName()const
	{
		return name;
	}
private:
	int age;
	string name;
};

class compare_Name
{
public:
	bool operator()(const aa& s1, const aa& s2)const//const不能丢
	{
		return s1.getName() < s2.getName();
	}
};

int main()
{
	cout << "--------------------pair类型------------------" << endl;
	pair<int, string> s;
	s.first = 1;
	s.second = "hzh";
	cout << s.first << "\t" << s.second << endl;
	s = make_pair(10, "abc");
	cout << s.first << "\t" << s.second << endl;
	cout << "--------------------map类型(排序去重)------------------" << endl;
	/*map中存的 pair类型的结构体 */
    map<string, string> str;
	str["A"] = "hzh";
	str["B"] = "abc";
	//方式 1
	str.insert(pair<string, string>("F", "czh"));
	//方式 2
	str.insert(make_pair("G", "bbc"));
	//方式 3
	str.insert(map<string,string>::value_type("Q", "abc"));
	//方式 4
	str["G"] = "hello";
	//  cout<<str["P"]<<endl;//使用这种方法输出一定要确保key值存在

	str["C"] = "def";
	str["C"] = "...";//键值相同覆盖
	for (auto v : str)
	{
		cout << v.first << "\t" << v.second << endl;
	}
	cout << "----------------------操作自定义类型------------------" << endl;
	map<aa, string,greater<>> hh;
	hh.insert(pair<aa,string>(aa(18, "def"), "你好"));
	hh[aa(19, "cbd")] = "不好";
	hh[aa(20, "bnm")] = "哦哦";
	hh[aa(21, "abc")] = "(⊙o⊙)…";
	for (auto v : hh)
	{
		cout << v.first << "\t" << v.second << endl;
	}
	cout << "-------------------多集合map类型(排序,不能去重)-----------------" << endl;
	//不能下标法插入
	multimap<int, string> ss;
	ss.insert(make_pair(1, "aaa"));
	ss.insert(make_pair(2, "bbb"));
	ss.insert(make_pair(3, "ccc"));
	ss.insert(make_pair(4, "ddd"));
	ss.insert(make_pair(4, "eee"));
	ss.insert(make_pair(5, "fff"));
	for (auto v : ss)
	{
		cout << v.first << "  " << v.second << endl;
	}
	return 0;
}
```

### 5. 元组tuple

```c++
#include<iostream>
#include<string>
#include<tuple>
using namespace std;

struct Info
{
	int age;
	string name;
	int math;
	int chinese;
	int english;
	int chemistry;
	void add()
	{
		cout << age << "   " << name << "   " << math << "   " << chinese << "   "
			<< english << "   " << chemistry << endl;
	}
};

int main()
{
	tuple<int, string> ss={18,"hello"};
	tuple<int, int, int, int> bb = {60,70,80,90 };
	tuple<string, string> cc = make_tuple("abc", "qwe");
	tuple<string, int> dd = forward_as_tuple("元组", 1);
	cout << "-------------------遍历----------------" << endl;
	//1.get访问
	cout << "get访问:" << get<0>(ss) << "\t" << get<1>(ss) << endl;//只能传真正的常量
	//2.tie访问
	int age;
	string name;
	tie(age, name) = ss;
	cout << "tie访问:" << age << "\t" << name << endl;
	//2.1 tie忽略数据
	tie(age, ignore) = ss;
	cout << "tie忽略数据:" << age << endl;
	//3.元组合并
	auto result = tuple_cat(ss, bb);
	struct Info  info;
	tie(info.age, info.name, info.math, info.chinese, info.english, info.chemistry) = result;
	cout << "合并打印:";
	info.add();

	return 0;
}
```

## 二:迭代器

### 1.分类

```c++
//正向迭代器 常正向 反向迭代器 常反向
begin(),end()  cbegin(),cend()  rbegin() rend()   crbegin() crend()
```

​							**1.前向迭代器 2.双向迭代器 3.随机访问迭代器 4.输入迭代器 5.输出迭代器**

|      容器      |           方式           |
| :------------: | :----------------------: |
|     array      | 随机访问 ++,--,+,+=,-,-= |
|     vector     | 随机访问 ++,--,+,+=,-,-= |
|     deque      | 随机访问 ++,--,+,+=,-,-= |
|      list      |        双向 ++,--        |
|  set/multiset  |        双向 ++,--        |
|  map/multimap  |        双向 ++,--        |
|     stack      |     不支持迭代器访问     |
|     queue      |     不支持迭代器访问     |
| priority_queue |     不支持迭代器访问     |

### 2.迭代器辅助函数:

#### 1. void advance(iterator&, off);

```c++
//迭代器走off个单位
//操作的是源迭代器
auto it = end(l);
advance(it, -4);	
cout << it->getName() << "\t" << it->getAge() << endl;
advance(it, 1);
cout << it->getName() << "\t" << it->getAge() << endl;
```

#### 2.distance(iterator first, iterator second);

```c++
//迭代器之间的距离	
distance(l.begin(), l.end())
```

```c++
auto it = l.end();
advance(it, -1);
iter_swap(l.begin(), it);
```

#### 3.iter_swap(iterator first, iterator second)

```c++
//交换两个迭代器的内容
auto it = l.end();
advance(it, -1);
iter_swap(l.begin(), it);
```

#### 4.prev(it,off)  next(it,off) begin(容器) end(容器)

```c++
//off可+可-
```

### 3.输出型迭代器	输入型迭代器

#### 3.1 ostream_iterator< type >

```c++
vector<int> s{ 1,2,3,5,6 };
//ostream_iterator<int>  it_os(cout);
ostream_iterator<int>  it_os(cout," ");//数据之间有空格
*it_os = 10;
*it_os = 20;
*it_os = 30;//依次打印的屏幕上
cout << endl;
copy(s.begin(), s.end(), it_os);//copy算法 
//add
//10 20 30
//1 2 3 5 6
```

#### 3.2 istream_iterator< type >

```c++
vector<int> s;
istream_iterator<int> it_error;
istream_iterator<int> it_is(cin);
while (it_is!=it_error)
{
    s.push_back(*it_is);
    it_is++;
}
for (auto v : s)
    cout << v << " ";
cout << endl;
//输入:1 2 3 4 5 6 7 8 9 ss
//输出:1 2 3 4 5 6 7 8 9
```

