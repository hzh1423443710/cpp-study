## detach参数传递

**注意:**

> 1. **detach时不要传指针**
>
> 2. **detach不要使用隐式类型转换**
>
>    (可能子线程参数还没来的及将参数转化为自己的类型，主线程就已经执行完毕了)
>
>    **explicit 可以避免隐式类型转换**，所以要避免隐式类型转换，传参时应传递函数参数类型
>
> 3. **detach成员函数/仿函数**作为线程入口函数，**不能传指针和引用**，只能值拷贝，临时对象可以detach
>
> 4. **智能指针unique_ptr不能使用detach**
>
>    主线程申请的堆内存move到子线程，如果主线程先于子线程结束，虽然主线程的智能指针对象已没有所有权，但申请的内存会有OS回收(进程结束)，子线程依然访问不到。

Example：创建线程时一定会在主线程中构造出匿名对象

```c++
class Cat
{
public:
	Cat(int num) :num(num)
	{
		std::cout << "constructor - " << this <<  std::endl;
	}
	Cat(const Cat& other) :num(other.num)
	{
		std::cout << "copy constructor - " << this << std::endl;
	}

public:
	int num;

};
void test(const Cat& b)
{
	std::cout << "子线程-Cat:" << b.num << "\t" << &b << std::endl;
}
int main()
{
	std::thread t0(test,10);		//隐式转换 可能主线程结束了还没转换
	//std::thread t(test,Cat(10));//匿名对象  创建线程时一定会构造(主线程结束之前)
	t0.detach();
}
```

**隐式**类型转换传递参数在**子线程中构造**

**显式**:传递参数在**主线程中构造**



## 单例设计模式线程共享

- 使用mutex

```c++
class Singleton
{
	class Delete
	{
	public:
		~Delete()
		{
			if (ptr_ == nullptr)
				return;
			delete ptr_;
			ptr_ = nullptr;
		}
	};
public:
	static Singleton* getInstance()
	{
		if (ptr_ == nullptr) {//两层判断 + mutex 线程同步
			std::lock_guard<std::mutex> lock(mtx_);
			if (ptr_ == nullptr) {
				ptr_ = new Singleton();
				static Delete del;
			}
		}
		return ptr_;
	}
	void fun()
	{
		std::cout << "Hello Singleton" << ",thread id:" << std::this_thread::get_id() << std::endl;
	}
private:
	static Singleton* ptr_;
	static std::mutex mtx_;
};
Singleton* Singleton::ptr_ = nullptr;
```

- 使用std::call_once

```c++
std::once_flag g_once;
class Singleton
{
	class Delete
	{
	public:
		~Delete()
		{
			if (ptr_ == nullptr)
				return;
			delete ptr_;
			ptr_ = nullptr;
		}
	};
public:
	static Singleton* getInstance()
	{
		std::call_once(g_once, createInstance);//多线程只调用一次
		return ptr_;
	}
	void fun()
	{
		std::cout << "Hello Singleton" << ",thread id:" << std::this_thread::get_id() << std::endl;
	}
private:
	static void  createInstance()
	{
		ptr_ = new Singleton();
		static Delete del;
	}
private:
	static Singleton* ptr_;
};
Singleton* Singleton::ptr_ = nullptr;
```

