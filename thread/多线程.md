# 多线程

- **同一个进程中的多个线程共享该进程的所有系统资源**
- **多个线程访问同一进程的共享资源会发生冲突**

任务函数可以是**普通函数、类的非静态成员函数**、类的静态成员函数、lambda函数、仿函数

**不能拷贝和赋值,可以移动**

- 先创建的子线程不一定跑得最快（程序运行的速度有很大的偶然性）。

- 线程的任务函数返回后，子线程将终止。

- 如果主程序（主线程）退出（不论是正常退出还是意外终止），全部的子线程将强行被终止。

> 用类的普通成员函数创建线程。
>
> - 必须先创建类的对象，必须保证对象的生命周期比子线程要长。
>
> - 第一个参数要**&地址**,第二个参数必须填对象的**this指针**，否则会拷贝对象。

## 传递方式

### 仿函数

```c++
class Function
{
public:
    void operator()() {
        std::cout << "仿函数" << std::endl;
    }
};
int main()
{
    std::thread t1(Function{});
    t1.join();
    return 0;
}
```

### 成员函数

```c++
class MyClass
{
public:
    void print(const int& id) {
        std::cout << id << std::endl;
    }
};
int main()
{
    MyClass m;
    int id = 1001;
    std::thread t1(&MyClass::print, &m, id);//或
    //std::thread t1(&MyClass::print, m, id);
    t1.join();
    return 0;
}
```

### 静态成员函数

## 1.线程回收

### join

join():阻塞等待，直到子线程退出

### detach

detach():分离子线程，子线程退出时，系统将自动回收资源。分离后的子线程不可join()。joinable = false

## 2.线程函数

​	thread命名空间:get_id()、sleep_for()、sleep_until()、yield()

### get_id()

### sleep_for()

该函数让线程休眠一段时间。

```c++
template <class Rep, class Period>
void sleep_for (const chrono::duration<Rep,Period>& rel_time);
```

### sleep_until() 

该函数让线程休眠至指定时间点。（可实现定时任务）

```c++
template <class Clock, class Duration>
void sleep_until (const chrono::time_point<Clock,Duration>& abs_time);
```

### yield()

该函数让线程主动让出自己已经抢到的CPU时间片

```c++
void yield() noexcept;
```

### hardware_concurrency()

```c++
static unsigned hardware_concurrency() noexcept;   // 返回硬件线程上下文的数量。
```

### std::call_once()

在多线程环境中，某些函数只能被调用一次，例如：初始化某个对象，而这个对象只能被初始化一次。

在线程的任务函数中，可以用**std::call_once()**来保证某个函数只被调用一次。

```c++
include <mutex>
std::once_flag onceflag;
template< class callable, class... Args >
void call_once( std::once_flag& flag, Function&& fx, Args&&... args );
第一个参数是std::once_flag，用于标记函数fx是否已经被执行过。
第二个参数是需要执行的函数fx。
```

```c++
void onceFunction(int id)
{
	std::cout << id << "  " << __FUNCSIG__ << std::endl;
}

#if 1
std::atomic<int> g_flag = 1;
#else
std::once_flag g_onceflag;
#endif
void testOnce(int id)
{
#if 1
	if (g_flag) {
		g_flag = 0;
		onceFunction(id);
	}
#else
	std::call_once(g_onceflag, onceFunction,id);
#endif
}

int main()
{
	int num = std::thread::hardware_concurrency();
	std::vector<std::thread> threads;
	threads.reserve(num);
	for (int i = 0; i < num; ++i) {
		threads.emplace_back(testOnce, i + 1);
	}
	for (auto& v : threads) {
		v.join();
	}
	return 0;
}
```

### 原生句柄 native_handle()

​	C++11定义了线程标准，不同的平台和编译器在实现的时候，本质上都是对操作系统的线程库进行封装，会损失一部分功能。

​	为了弥补C++11线程库的不足，thread类提供了native_handle()成员函数，用于获得与操作系统相关的原生线程句柄，操作系统原生的线程库就可以用原生线程句柄操作线程。

```c++
pthread_t pid = t.navive_handle();
```



## 3.线程传递参数

- 值传递 

>  **拷贝两次**

- 引用传递

> 常引用：**拷贝一次**
>
> 左值引用：**不拷贝** 需要std::ref()

- 指针传递

**注意:**

> - detach时不要传指针
> - 不要使用隐式类型转换(**可能子线程参数还没来的及将参数转化为自己的类型，主线程就已经执行完毕了**) 
> - explicit 可以避免隐式类型转换, 所以要传递真正的参数类型,避免隐式转换(主线程结束前会先构造临时对象)

**总结:**

- 普通类型值传递

- 类类型传引用

```c++
class Base
{
public:
	Base() :num(0)
	{
		std::cout << __FUNCSIG__ << std::endl;
	}
	Base(int num):num(num)
	{
		std::cout << __FUNCSIG__ << std::endl;
	}
	Base(const Base& other) :num(other.num)
	{
		std::cout << __FUNCSIG__ << std::endl;
	}
	~Base()
	{
		std::cout << __FUNCSIG__ << std::endl;
	}
	int num;
};

void transmitByref1(const Base& base)//拷贝一次
{
	std::cout << "child thread " << std::this_thread::get_id() << " , num = " << base.num << std::endl;
}

void transmitByvalue(Base base)//拷贝两次
{
	std::cout << "child thread " << std::this_thread::get_id() << " , num = " << base.num << std::endl;
}

void transmitByref(Base& base)//不拷贝
{
	std::cout << "child thread " << std::this_thread::get_id() << " , num = " << base.num << std::endl;
	base.num = -1;
}

int main()
{
	std::cout << "<------------------------------------------------------------------>" << std::endl;

	int i{ 100 };
	Base base(1234);
	std::thread t(transmitByref, std::ref(base));

	t.join();

	std::cout << "main thread " << std::this_thread::get_id() << " , num = " << base.num << std::endl;
	Sleep(1000);
	std::cout << "<------------------------------------------------------------------>" << std::endl;
	return 0;
}
```

## 4.互斥锁

### mutex

C++11提供了四种互斥锁：

- **mutex**：互斥锁。

> - 同一线程:对同一个mutex不能加锁2次,否则报错,加锁了后一定记得解锁,否则报错
> - 不同线程:lock了其他线程会阻塞

- **timed_mutex**：带超时机制的互斥锁。

- **recursive_mutex**：递归互斥锁。

- **recursive_timed_mutex**：带超时机制的递归互斥锁。

包含头文件：#include <mutex>

#### lock()

​	未锁定状态:加锁

​	锁定状态:阻塞

#### unlock()

​	只有持有锁的线程才能解锁

#### try_lock()

​	未锁定状态:加锁 返回true

​	锁定状态:直接返回false 不阻塞

### timed_mutex

增加了两个成员函数：

​	bool try_lock_for(时间长度);

​	bool try_lock_until(时间点);

### recursive_mutex

​	递归互斥锁允许同一线程多次获得互斥锁，可以解决同一线程多次加锁造成的死锁问题**(普通的mutex在统一线程中不能多次lock)**.

> std::recursive_mutex mtx1;
> mtx1.lock();
> mtx1.lock();
> std::cout << "hello" << std::endl;//正常输出
> mtx1.unlock();
> mtx1.unlock();



​	`recursive_mutex` 的使用场景之一是保护类中的共享状态，而类的成员函数可能相互调用

```c++
class X {
    std::recursive_mutex m;
    std::string shared;
  public:
    void fun1() {
      std::lock_guard<std::recursive_mutex> lk(m);
      shared = "fun1";
      std::cout << "in fun1, shared variable is now " << shared << '\n';
    }
    void fun2() {
      std::lock_guard<std::recursive_mutex> lk(m);
      shared = "fun2";
      std::cout << "in fun2, shared variable is now " << shared << '\n';
      fun1(); // 递归锁在此处变得有用
      std::cout << "back in fun2, shared variable is " << shared << '\n';
    };
};
 
int main() 
{
    X x;
    std::thread t1(&X::fun1, &x);
    std::thread t2(&X::fun2, &x);
    t1.join();
    t2.join();
}
```

## 5.lock_guard和unique_lock

模板类 RAII

### std::lock_guard<>

- lock_guard在**构造函数中加锁**，在**析构函数中解锁**。**RAII**思想
- 没有成员函数

```c++
#include <mutex>
std::mutex g_mutex;
std::lock_guard<std::mutex> lock(mutex);//作用域 
```

**std::lock() 和 std::lock_guard<>**

> 可以解决：多个线程中因为**锁的顺序**问题导致死锁 如循环等待的死锁问题

std::lock(...) :可以一次锁住两个或者两个以上的互斥量。(最少锁两个)

std::lock_guard<> lock(mutex,**std::adopt_lock**) :收养mutex,不进行加锁 只解锁

Example:

```c++
std::mutex g_mtx1;
std::mutex g_mtx2;
void test1(int i)
{
	using namespace std::chrono_literals;
	std::lock(g_mtx1,g_mtx2);//对g_mtx1,g_mtx2同时加锁
	std::lock_guard<std::mutex> lock1(g_mtx1, std::adopt_lock);//g_mtx1出了作用域解锁
	std::lock_guard<std::mutex> lock2(g_mtx2, std::adopt_lock);//g_mtx2出了作用域解锁
	while (true) {
		std::this_thread::sleep_for(3s);
		break;
	}
	std::cout << "after test1" << std::endl;
}

void test2(int i)
{
	using namespace std::chrono_literals;
	std::this_thread::sleep_for(4s);
	if (g_mtx1.try_lock()) {
		std::cout << "加锁成功 g_mtx1" << std::endl;
		g_mtx1.unlock();
	}
	else {
		std::cout << "加锁失败 g_mtx1" << std::endl;
	}

	if (g_mtx2.try_lock()) {
		std::cout << "加锁成功 g_mtx2" << std::endl;
		g_mtx2.unlock();
	}
	else {
		std::cout << "加锁失败 g_mtx2" << std::endl;
	}
}
void testThread()
{
	std::thread t1(test1, 1);
	std::thread t2(test2, 2);
	t1.join();
	t2.join();
}
```

### std::unique_lock<>

可以通过构造函数和析构函数控制锁的作用范围，也可以在构造函数中延时加锁，在需要的时候手动加锁和解锁。**RAII思想**

- 有很多成员函数
- 可移动 但不能复制
  - 缺省参数和std::lock_guard<>效果一样


**第二个参数:**	

- **std::adopt_lock_t**:表示mutex已经被lock(**构造函数中不再lock 维护的mutex必须提前被lock**),析构时进行unlock 
- **std::defer_lock_t**:不获得互斥的所有权，构造时不会lock，可以手动自由lock unlock.(**维护的mutex不能提前被lock**)
- **std::try_to_lock_t**:尝试获得互斥的所有权而不阻塞(**维护的mutex不能提前被lock**)

#### 成员函数

##### lock()

##### unlock()

##### try_lock()

> ​	不阻塞。拿到了mutex返回true，没拿到返回false

##### owns_lock() operator bool()

> ​	检查是否持有mutex

##### release()

> ​	返回它所管理的mutex对象指针，并**释放所有权**；也就是说，这个unique_lock和mutex不再有关系。	
>
> 如果原来mutex对像处于加锁状态，**你有责任接管过来并负责解锁**。（release返回的是原始mutex的指针）

### 资源消耗比较

​	unique_lock相对而言更加灵活,对于资源的消耗明显要大一些，因为它要维持mutex的状态；
lock_guard虽然笨重一些,但是资源消耗相对要小一点。



## 原子类型 atomic

C++11提供了atomic<T>模板类（结构体），用于支持原子类型，模板参数可以是bool、char、int、long、long long、指针类型（不支持浮点类型和自定义数据类型）。

原子操作由CPU指令提供支持，它的性能比锁和消息传递更高，并且，不需要程序员处理加锁和释放锁的问题，支持修改、读取、交换、比较并交换等操作。

头文件：#include <atomic>

```c++
#include <atomic>
std::atomic<long long> g_num;//对g_num的操作原子操作 
```

## 死锁

### 场景1

​	2个线程，2把锁mutex1 mutex2

​	线程1：先lock mutex1，再去那lock mutex2（此时mutex2已被线程2 lock了）

​	线程2：先lock mutex2，再去那lock mutex1（此时mutex1已被线程1 lock了）

​	卡死

#### 解决

- 让2个mutex lock的顺序一致
- 使用std::lock(mutex1,mutex2,...) 同时锁住多个mutex(要么都锁住 要么都不锁)，用lock_guard<>收养mutex



## 条件变量

条件变量是一种线程同步机制。当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。

头文件<condition_variable>

- condition_variable：只支持与**普通mutex**搭配，效率更高。
- condition_variable_any: 是一种通用的条件变量，可以与任意mutex搭配（包括用户自定义的锁类型）。

### 成员函数:

#### wait()

先解锁再阻塞 - 被唤醒后解除阻塞(原子操作)

wait 导致当前线程阻塞直至条件变量被**通知**，或**虚假唤醒发生**，可选地循环**直至满足某谓词**。

```c++
void wait( std::unique_lock<std::mutex>& lock );
//Predicate是lambda表达式。
template< class Predicate >
void wait( std::unique_lock<std::mutex>& lock, Predicate pred );
//以上二者都被notify_one())或notify_broadcast()唤醒，但是
//第二种方式是唤醒后也要满足Predicate的条件。
//如果不满足条件，继续解锁互斥量，然后让线程处于阻塞或等待状态。
//第二种等价于
while (!pred())
{
    wait(lock);
}
```

> ​	因为要先对mutex先解锁再阻塞,所以只能使用unique_lock<std::mutex> 对其mutex unlock

#### wait_for()

wait_for 导致当前线程阻塞直至条件变量被**通知**，或**虚假唤醒发生**，或者**超时返回**。

```c++
（1）
template< class Rep, class Period >
std::cv_status wait_for( std::unique_lock<std::mutex>& lock,
                         const std::chrono::duration<Rep, Period>& rel_time);
                         
（2）
template< class Rep, class Period, class Predicate >
bool wait_for( std::unique_lock<std::mutex>& lock,
               const std::chrono::duration<Rep, Period>& rel_time,
               Predicate pred);
```

返回值说明：

（1）若经过 rel_time 所指定的关联时限则为 std::cv_status::timeout ，否则为 std::cv_status::no_timeout 。

（2）若经过 rel_time 时限后谓词 pred 仍求值为 false 则为 false ，否则为 true 。


Example:

```c++
std::condition_variable cv;
std::mutex cv_m; 
int i = 0;

void waits(const int& id)
{
	std::unique_lock<std::mutex> lk(cv_m);
	std::cerr << id << " Waiting... \n";
	//cv.wait(lk, [] {return i == 1; });
#if 0
	std::cv_status status = cv.wait_for(lk, std::chrono::seconds(2));
	if (status == std::cv_status::no_timeout) {
		std::cout << id << " 没有超时" << std::endl;
		std::cerr << id << " finished waiting. i == 1\n";
	}
	else {
		std::cout << id << " 超时" << std::endl;
	}
#else
	bool success = cv.wait_for(lk, std::chrono::seconds(3), [] () {
		return i == 1;
	});
	if (success) {
		std::cout << id << " 没有超时 " << "finished waiting. i == 1\n";
	}
	else {
		std::cout << id << " 超时" << std::endl;
	}
#endif

}

void signals()
{
	std::this_thread::sleep_for(std::chrono::seconds(1));
	std::cout << "signals ready notify" << std::endl;
	{
		std::lock_guard<std::mutex> lk(cv_m);
		std::cerr << "first Notifying...\n";
		i = 1;
	}
	cv.notify_one();
	std::this_thread::sleep_for(std::chrono::seconds(1));
	{
		std::lock_guard<std::mutex> lk(cv_m);
		i = 0;
	}
	
	std::this_thread::sleep_for(std::chrono::seconds(1));
	{
		std::lock_guard<std::mutex> lk(cv_m);
		std::cerr << "Notifying again...\n";
		i = 1;
	}
	cv.notify_all();
}

int main()
{
	Base b;

	std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);
	t1.join();
	t2.join();
	t3.join();
	t4.join();

	return 0;
}
```

#### notify_one()

通知一个等待的线程

#### notify_all()

通知所有等待的线程