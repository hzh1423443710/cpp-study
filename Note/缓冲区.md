	缓冲区（Buffer）又称为缓存（Cache），是内存空间的一部分。也就是说，计算机在内存中预留了一定的存储空间，用来暂时保存输入或输出的数据，这部分预留的空间就叫做缓冲区（缓存）。

## 为什么要引入缓冲区（缓存）

​	缓冲区是为了让低速的输入输出设备和高速的用户程序能够协调工作，并降低输入输出设备的读写次数。

- 硬盘的速度要远低于 CPU

> ​	有了缓冲区，就可以将数据先放入缓冲区中（内存的读写速度也远高于硬盘），然后程序可以继续往下执行，等所有的数据都准备好了，再将缓冲区中的所有数据一次性地写入硬盘，这样程序就减少了等待的次数，变得流畅起来。

- 减少硬件设备的读写次数

> ​	我们的程序并不能直接读写硬件，它必须告诉操作系统，让操作系统内核（Kernel）去调用驱动程序，只有驱动程序才能真正的操作硬件。
>
> ​	从用户程序到硬件设备要经过好几层的转换，每一层的转换都有时间和空间的开销，而且开销不一定小；一旦用户程序需要密集的输入输出操作，这种开销将变得非常大，会成为制约程序性能的瓶颈。

## 缓冲区的类型

#### 1) 全缓冲

​	缓冲区的大小都有限制的，比如 1KB、4MB 等，数据量达到最大值时就清空缓冲区。

#### 2) 行缓冲

​	当在输入或者输出的过程中遇到换行符时，才执行真正的输入输出操作

​	是带有行缓冲的，用户输入的内容会先放入缓冲区，直到用户按下回车键，产生换行符\n，才会刷新缓冲区，进行真正的读取。

- Windows 平台下，输出设备是不带缓冲区的；
- Linux 和 Mac OS 平台下，输出设备带有行缓冲区。

#### 3) 不带缓冲

不带缓冲区，数据就没有地方缓存，必须立即进行输入输出。

- getche()、getch() 就不带缓冲区

- Windows 下的 printf() 也不带缓冲区，不管最后有没有换行符\n，都会立即输出

- 错误信息输出函数 perror() 也没有缓冲区

## 缓冲区的刷新（清空）

- 不管是行缓冲还是全缓冲，缓冲区满时会自动刷新；
- 行缓冲遇到换行符 \n 时会刷新；
- 关闭文件时会刷新缓冲区；
- 程序关闭时一般也会刷新缓冲区，这个是由标准库来保障的；
- 使用特定的函数也可以手动刷新缓冲区



Example:

- 写文件时,缓冲区满后或刷新缓冲区才写入文件.
- `endl` `flush()` 会刷新缓冲区
-  `obj << unitbuf` :设置自动刷新缓冲区

> 缺省的缓冲方式:nounitbuf
>
> 设置自动刷新缓冲区:unitbuf

```c++
int main()
{
    std::ofstream  of("c:/users/hzh/desktop/a.txt");
	//of << std::unitbuf; //设置每次操作后自动刷新缓冲区
    if(of){
        for(int i = 0; i < 1000; ++i) {
            of << i << "  " << "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n";
            //of << i << "  " << "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" << std::endl;
            //of.flush();//刷新缓冲区
            Sleep(100);
        }
        of.close();
    }
    else {
        std::cout << "open failed" << std::endl;
    }
    return 0;
}
```

> - 不会0.1s写一行,一次写一堆,停一会,再写一堆
> - 使用`endl` 会 0.1s 写一行